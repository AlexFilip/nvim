# TODO
#  - Finish tagged union (enum, struct { union })

global !p

def split_member_name(name) -> list:
	"""
	Separates a name by underscores then internally by case.
	If it finds an uppercase character preceeded by a lowercase,
	then it splits between the 2 characters.
	"""
	result = []
	if name:
		underscore_separated = name.split('_')
		for comp in underscore_separated:
			last_start_index = 0
			for i, c in enumerate(comp):
				if c.isupper():
					string_to_append = ""
					if comp[i-1].islower():
						string_to_append = comp[last_start_index:i]

					last_start_index = i

					if len(string_to_append) > 0:
						result.append(string_to_append.lower())
			result.append(comp[last_start_index:])

	return result

def member_name_to_camel_case(name: str) -> str:
	name_components = split_member_name(name)
	return "".join([comp[0].upper() + comp[1:].lower() for comp in name_components])

def member_name_to_snake_case(name: str) -> str:
	name_components = split_member_name(name)
	return "_".join([comp.lower() for comp in name_components])

def filter_type_name(name):
	for i, c in enumerate(name):
		if not c.isalpha() and c != '_':
			name = name[:i]
			break
	return name

def snake_to_camel_case(name: str) -> str:
	name = filter_type_name(name)
	name_components = name.split('_')
	return "".join([comp[0].upper() + comp[1:].lower() for comp in name_components if comp])

def members_to_args(members_string: str) -> str:
	line_components = [v.strip().replace(";", "") for v in members_string.strip().splitlines()]
	return ", ".join(line_components)

def components_to_assignments(component_list: list, is_pointer: bool) -> str:
		def has_name(components: list) -> bool:
			return len(components) > 1 and all(c.isalpha() or c.isdigit() or c == '_' for c in components[-1])

		def get_name(components):
			return components[-1] if has_name(components) else ""

		struct_accessor = "->" if is_pointer else "."
		names = [get_name(comp.split(" ")) for comp in component_list]
		longest = max(len(name) for name in names)

		assignments = ["    Result{1}{0}{2} = {0};".format(
			name,
			struct_accessor,
			" " * (longest - len(name)))
		for name in names]
		
		return "\n".join(assignments)

def members_to_assignment(members_string: str, is_pointer: bool) -> str:
	if members_string:
		line_components = [v.strip().replace(";", "") for v in members_string.splitlines()]
		return components_to_assignments(line_components, is_pointer);
	else:
		return ""

def args_to_assignment(argument_string: str, is_pointer: bool) -> str:
	if argument_string:
		arguments = [v.strip() for v in argument_string.split(",")]
		return components_to_assignments(arguments, is_pointer);
	else:
		return ""

def struct_initializer(_type: str):
	t = _type.strip()
	if t.endswith("*"):
		return "({}) malloc(sizeof({}))".format(t, t[:-1])
	else:
		return "{}"
	pass

stdint_regex = re.compile("^u?int(8|16|32|64)_t$")
def result_definition_with_type(_type):
	global stdint_regex

	t = _type.strip()
	result = ""
	if t != "void":
		ResultInitializer = "{}"
		if t.endswith("short") or \
		   t.endswith("int") or \
		   t.endswith("long") or \
		   t.startswith("unsigned") or \
		   stdint_regex.match(t):
			ResultInitializer = "0"
		elif t == "char":
			ResultInitializer = "'\\0'"
		elif t == "double":
			ResultInitializer = "0.0";
		elif t == "float":
			ResultInitializer = "0.0f";
		elif t.endswith("*"):
			ResultInitializer = "NULL";

		result = "{} Result = {};\n\n    ".format(t, ResultInitializer);
	return result

endglobal

snippet ctor "A constructor function" b
internal ${1:return_type}
`!p snip.rv=snake_to_camel_case(t[1])`($2) {
	$1 Result = `!p snip.rv=struct_initializer(t[1])`;

`!p snip.rv=args_to_assignment(t[2], t[1].endswith("*"))`

	return Result;
}
endsnippet

# ---

snippet struct "A struct and associated constructor" b
struct `!p snip.rv=filter_type_name(t[1])` {
	$2
};

internal ${1:type_name}
`!p snip.rv=snake_to_camel_case(t[1])`(`!p snip.rv=members_to_args(t[2])`) {
	$1 Result = `!p snip.rv=struct_initializer(t[1])`;

`!p snip.rv=members_to_assignment(t[2], t[1].endswith("*"))`

	return Result;
}
endsnippet

# ---
# 

snippet main "Main funcition declaration" b
int
main(int ArgCount, char* Args[]) {
	$0
}
endsnippet

snippet libstd "Common include statements" b
endsnippet

snippet if "If statement"
if($1) {
	$0
}
endsnippet

snippet elif "If statement"
else if($1) {
	$0
}
endsnippet

snippet else "If statement"
else {
	$0
}
endsnippet

snippet while "While loop"
while($1) {
	$0
}
endsnippet

snippet for "For loop"
for(int ${1:Index} = 0; $1 < ${3:ArrayLength(${2:ArrayName})}; ++$1) {
	$0
}
endsnippet

snippet switch "Switch statement"
switch($1) {
	case $2: {
		$0
		break;
	}
	default: {
		break;
	}
}
endsnippet

snippet fn "Basic funciton definition"
${2:void} ${1:FunctionName}($3) {
	`!p snip.rv=result_definition_with_type(t[2])`$0`!p snip.rv="" if t[2] == "void" else "\n\n    return Result;"`
}
endsnippet

# TODO
# snippet tunion "A tagged union definition"
# enum $1_type {
# 	`!p snip.rv=""`
# };
# 
# struct ${1:name} {
# 	$1_type Type;
# 	union {
# 		$2
# 	};
# }
# endsnippet
